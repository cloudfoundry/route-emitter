// This file was generated by counterfeiter
package fakeroutingtable

import (
	"sync"

	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/route-emitter/routing_table"
	"code.cloudfoundry.org/route-emitter/routing_table/schema/endpoint"
)

type FakeNATSRoutingTable struct {
	RouteCountStub        func() int
	routeCountMutex       sync.RWMutex
	routeCountArgsForCall []struct{}
	routeCountReturns     struct {
		result1 int
	}
	routeCountReturnsOnCall map[int]struct {
		result1 int
	}
	SwapStub        func(newTable routing_table.NATSRoutingTable, domains models.DomainSet) routing_table.MessagesToEmit
	swapMutex       sync.RWMutex
	swapArgsForCall []struct {
		newTable routing_table.NATSRoutingTable
		domains  models.DomainSet
	}
	swapReturns struct {
		result1 routing_table.MessagesToEmit
	}
	swapReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	SetRoutesStub        func(key endpoint.RoutingKey, routes []routing_table.Route, modTag *models.ModificationTag) routing_table.MessagesToEmit
	setRoutesMutex       sync.RWMutex
	setRoutesArgsForCall []struct {
		key    endpoint.RoutingKey
		routes []routing_table.Route
		modTag *models.ModificationTag
	}
	setRoutesReturns struct {
		result1 routing_table.MessagesToEmit
	}
	setRoutesReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	GetRoutesStub        func(key endpoint.RoutingKey) []routing_table.Route
	getRoutesMutex       sync.RWMutex
	getRoutesArgsForCall []struct {
		key endpoint.RoutingKey
	}
	getRoutesReturns struct {
		result1 []routing_table.Route
	}
	getRoutesReturnsOnCall map[int]struct {
		result1 []routing_table.Route
	}
	RemoveRoutesStub        func(key endpoint.RoutingKey, modTag *models.ModificationTag) routing_table.MessagesToEmit
	removeRoutesMutex       sync.RWMutex
	removeRoutesArgsForCall []struct {
		key    endpoint.RoutingKey
		modTag *models.ModificationTag
	}
	removeRoutesReturns struct {
		result1 routing_table.MessagesToEmit
	}
	removeRoutesReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	AddEndpointStub        func(key endpoint.RoutingKey, routingEndpoint routing_table.Endpoint) routing_table.MessagesToEmit
	addEndpointMutex       sync.RWMutex
	addEndpointArgsForCall []struct {
		key             endpoint.RoutingKey
		routingEndpoint routing_table.Endpoint
	}
	addEndpointReturns struct {
		result1 routing_table.MessagesToEmit
	}
	addEndpointReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	RemoveEndpointStub        func(key endpoint.RoutingKey, routingEndpoint routing_table.Endpoint) routing_table.MessagesToEmit
	removeEndpointMutex       sync.RWMutex
	removeEndpointArgsForCall []struct {
		key             endpoint.RoutingKey
		routingEndpoint routing_table.Endpoint
	}
	removeEndpointReturns struct {
		result1 routing_table.MessagesToEmit
	}
	removeEndpointReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	EndpointsForIndexStub        func(key endpoint.RoutingKey, index int32) []routing_table.Endpoint
	endpointsForIndexMutex       sync.RWMutex
	endpointsForIndexArgsForCall []struct {
		key   endpoint.RoutingKey
		index int32
	}
	endpointsForIndexReturns struct {
		result1 []routing_table.Endpoint
	}
	endpointsForIndexReturnsOnCall map[int]struct {
		result1 []routing_table.Endpoint
	}
	MessagesToEmitStub        func() routing_table.MessagesToEmit
	messagesToEmitMutex       sync.RWMutex
	messagesToEmitArgsForCall []struct{}
	messagesToEmitReturns     struct {
		result1 routing_table.MessagesToEmit
	}
	messagesToEmitReturnsOnCall map[int]struct {
		result1 routing_table.MessagesToEmit
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNATSRoutingTable) RouteCount() int {
	fake.routeCountMutex.Lock()
	ret, specificReturn := fake.routeCountReturnsOnCall[len(fake.routeCountArgsForCall)]
	fake.routeCountArgsForCall = append(fake.routeCountArgsForCall, struct{}{})
	fake.recordInvocation("RouteCount", []interface{}{})
	fake.routeCountMutex.Unlock()
	if fake.RouteCountStub != nil {
		return fake.RouteCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.routeCountReturns.result1
}

func (fake *FakeNATSRoutingTable) RouteCountCallCount() int {
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	return len(fake.routeCountArgsForCall)
}

func (fake *FakeNATSRoutingTable) RouteCountReturns(result1 int) {
	fake.RouteCountStub = nil
	fake.routeCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeNATSRoutingTable) RouteCountReturnsOnCall(i int, result1 int) {
	fake.RouteCountStub = nil
	if fake.routeCountReturnsOnCall == nil {
		fake.routeCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.routeCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeNATSRoutingTable) Swap(newTable routing_table.NATSRoutingTable, domains models.DomainSet) routing_table.MessagesToEmit {
	fake.swapMutex.Lock()
	ret, specificReturn := fake.swapReturnsOnCall[len(fake.swapArgsForCall)]
	fake.swapArgsForCall = append(fake.swapArgsForCall, struct {
		newTable routing_table.NATSRoutingTable
		domains  models.DomainSet
	}{newTable, domains})
	fake.recordInvocation("Swap", []interface{}{newTable, domains})
	fake.swapMutex.Unlock()
	if fake.SwapStub != nil {
		return fake.SwapStub(newTable, domains)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swapReturns.result1
}

func (fake *FakeNATSRoutingTable) SwapCallCount() int {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return len(fake.swapArgsForCall)
}

func (fake *FakeNATSRoutingTable) SwapArgsForCall(i int) (routing_table.NATSRoutingTable, models.DomainSet) {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return fake.swapArgsForCall[i].newTable, fake.swapArgsForCall[i].domains
}

func (fake *FakeNATSRoutingTable) SwapReturns(result1 routing_table.MessagesToEmit) {
	fake.SwapStub = nil
	fake.swapReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SwapReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.SwapStub = nil
	if fake.swapReturnsOnCall == nil {
		fake.swapReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.swapReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SetRoutes(key endpoint.RoutingKey, routes []routing_table.Route, modTag *models.ModificationTag) routing_table.MessagesToEmit {
	var routesCopy []routing_table.Route
	if routes != nil {
		routesCopy = make([]routing_table.Route, len(routes))
		copy(routesCopy, routes)
	}
	fake.setRoutesMutex.Lock()
	ret, specificReturn := fake.setRoutesReturnsOnCall[len(fake.setRoutesArgsForCall)]
	fake.setRoutesArgsForCall = append(fake.setRoutesArgsForCall, struct {
		key    endpoint.RoutingKey
		routes []routing_table.Route
		modTag *models.ModificationTag
	}{key, routesCopy, modTag})
	fake.recordInvocation("SetRoutes", []interface{}{key, routesCopy, modTag})
	fake.setRoutesMutex.Unlock()
	if fake.SetRoutesStub != nil {
		return fake.SetRoutesStub(key, routes, modTag)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) SetRoutesCallCount() int {
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	return len(fake.setRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) SetRoutesArgsForCall(i int) (endpoint.RoutingKey, []routing_table.Route, *models.ModificationTag) {
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	return fake.setRoutesArgsForCall[i].key, fake.setRoutesArgsForCall[i].routes, fake.setRoutesArgsForCall[i].modTag
}

func (fake *FakeNATSRoutingTable) SetRoutesReturns(result1 routing_table.MessagesToEmit) {
	fake.SetRoutesStub = nil
	fake.setRoutesReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) SetRoutesReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.SetRoutesStub = nil
	if fake.setRoutesReturnsOnCall == nil {
		fake.setRoutesReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.setRoutesReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) GetRoutes(key endpoint.RoutingKey) []routing_table.Route {
	fake.getRoutesMutex.Lock()
	ret, specificReturn := fake.getRoutesReturnsOnCall[len(fake.getRoutesArgsForCall)]
	fake.getRoutesArgsForCall = append(fake.getRoutesArgsForCall, struct {
		key endpoint.RoutingKey
	}{key})
	fake.recordInvocation("GetRoutes", []interface{}{key})
	fake.getRoutesMutex.Unlock()
	if fake.GetRoutesStub != nil {
		return fake.GetRoutesStub(key)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) GetRoutesCallCount() int {
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	return len(fake.getRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) GetRoutesArgsForCall(i int) endpoint.RoutingKey {
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	return fake.getRoutesArgsForCall[i].key
}

func (fake *FakeNATSRoutingTable) GetRoutesReturns(result1 []routing_table.Route) {
	fake.GetRoutesStub = nil
	fake.getRoutesReturns = struct {
		result1 []routing_table.Route
	}{result1}
}

func (fake *FakeNATSRoutingTable) GetRoutesReturnsOnCall(i int, result1 []routing_table.Route) {
	fake.GetRoutesStub = nil
	if fake.getRoutesReturnsOnCall == nil {
		fake.getRoutesReturnsOnCall = make(map[int]struct {
			result1 []routing_table.Route
		})
	}
	fake.getRoutesReturnsOnCall[i] = struct {
		result1 []routing_table.Route
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveRoutes(key endpoint.RoutingKey, modTag *models.ModificationTag) routing_table.MessagesToEmit {
	fake.removeRoutesMutex.Lock()
	ret, specificReturn := fake.removeRoutesReturnsOnCall[len(fake.removeRoutesArgsForCall)]
	fake.removeRoutesArgsForCall = append(fake.removeRoutesArgsForCall, struct {
		key    endpoint.RoutingKey
		modTag *models.ModificationTag
	}{key, modTag})
	fake.recordInvocation("RemoveRoutes", []interface{}{key, modTag})
	fake.removeRoutesMutex.Unlock()
	if fake.RemoveRoutesStub != nil {
		return fake.RemoveRoutesStub(key, modTag)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeRoutesReturns.result1
}

func (fake *FakeNATSRoutingTable) RemoveRoutesCallCount() int {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return len(fake.removeRoutesArgsForCall)
}

func (fake *FakeNATSRoutingTable) RemoveRoutesArgsForCall(i int) (endpoint.RoutingKey, *models.ModificationTag) {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return fake.removeRoutesArgsForCall[i].key, fake.removeRoutesArgsForCall[i].modTag
}

func (fake *FakeNATSRoutingTable) RemoveRoutesReturns(result1 routing_table.MessagesToEmit) {
	fake.RemoveRoutesStub = nil
	fake.removeRoutesReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveRoutesReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.RemoveRoutesStub = nil
	if fake.removeRoutesReturnsOnCall == nil {
		fake.removeRoutesReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.removeRoutesReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) AddEndpoint(key endpoint.RoutingKey, routingEndpoint routing_table.Endpoint) routing_table.MessagesToEmit {
	fake.addEndpointMutex.Lock()
	ret, specificReturn := fake.addEndpointReturnsOnCall[len(fake.addEndpointArgsForCall)]
	fake.addEndpointArgsForCall = append(fake.addEndpointArgsForCall, struct {
		key             endpoint.RoutingKey
		routingEndpoint routing_table.Endpoint
	}{key, routingEndpoint})
	fake.recordInvocation("AddEndpoint", []interface{}{key, routingEndpoint})
	fake.addEndpointMutex.Unlock()
	if fake.AddEndpointStub != nil {
		return fake.AddEndpointStub(key, routingEndpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addEndpointReturns.result1
}

func (fake *FakeNATSRoutingTable) AddEndpointCallCount() int {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return len(fake.addEndpointArgsForCall)
}

func (fake *FakeNATSRoutingTable) AddEndpointArgsForCall(i int) (endpoint.RoutingKey, routing_table.Endpoint) {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return fake.addEndpointArgsForCall[i].key, fake.addEndpointArgsForCall[i].routingEndpoint
}

func (fake *FakeNATSRoutingTable) AddEndpointReturns(result1 routing_table.MessagesToEmit) {
	fake.AddEndpointStub = nil
	fake.addEndpointReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) AddEndpointReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.AddEndpointStub = nil
	if fake.addEndpointReturnsOnCall == nil {
		fake.addEndpointReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.addEndpointReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveEndpoint(key endpoint.RoutingKey, routingEndpoint routing_table.Endpoint) routing_table.MessagesToEmit {
	fake.removeEndpointMutex.Lock()
	ret, specificReturn := fake.removeEndpointReturnsOnCall[len(fake.removeEndpointArgsForCall)]
	fake.removeEndpointArgsForCall = append(fake.removeEndpointArgsForCall, struct {
		key             endpoint.RoutingKey
		routingEndpoint routing_table.Endpoint
	}{key, routingEndpoint})
	fake.recordInvocation("RemoveEndpoint", []interface{}{key, routingEndpoint})
	fake.removeEndpointMutex.Unlock()
	if fake.RemoveEndpointStub != nil {
		return fake.RemoveEndpointStub(key, routingEndpoint)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeEndpointReturns.result1
}

func (fake *FakeNATSRoutingTable) RemoveEndpointCallCount() int {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return len(fake.removeEndpointArgsForCall)
}

func (fake *FakeNATSRoutingTable) RemoveEndpointArgsForCall(i int) (endpoint.RoutingKey, routing_table.Endpoint) {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return fake.removeEndpointArgsForCall[i].key, fake.removeEndpointArgsForCall[i].routingEndpoint
}

func (fake *FakeNATSRoutingTable) RemoveEndpointReturns(result1 routing_table.MessagesToEmit) {
	fake.RemoveEndpointStub = nil
	fake.removeEndpointReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) RemoveEndpointReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.RemoveEndpointStub = nil
	if fake.removeEndpointReturnsOnCall == nil {
		fake.removeEndpointReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.removeEndpointReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) EndpointsForIndex(key endpoint.RoutingKey, index int32) []routing_table.Endpoint {
	fake.endpointsForIndexMutex.Lock()
	ret, specificReturn := fake.endpointsForIndexReturnsOnCall[len(fake.endpointsForIndexArgsForCall)]
	fake.endpointsForIndexArgsForCall = append(fake.endpointsForIndexArgsForCall, struct {
		key   endpoint.RoutingKey
		index int32
	}{key, index})
	fake.recordInvocation("EndpointsForIndex", []interface{}{key, index})
	fake.endpointsForIndexMutex.Unlock()
	if fake.EndpointsForIndexStub != nil {
		return fake.EndpointsForIndexStub(key, index)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.endpointsForIndexReturns.result1
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexCallCount() int {
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	return len(fake.endpointsForIndexArgsForCall)
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexArgsForCall(i int) (endpoint.RoutingKey, int32) {
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	return fake.endpointsForIndexArgsForCall[i].key, fake.endpointsForIndexArgsForCall[i].index
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexReturns(result1 []routing_table.Endpoint) {
	fake.EndpointsForIndexStub = nil
	fake.endpointsForIndexReturns = struct {
		result1 []routing_table.Endpoint
	}{result1}
}

func (fake *FakeNATSRoutingTable) EndpointsForIndexReturnsOnCall(i int, result1 []routing_table.Endpoint) {
	fake.EndpointsForIndexStub = nil
	if fake.endpointsForIndexReturnsOnCall == nil {
		fake.endpointsForIndexReturnsOnCall = make(map[int]struct {
			result1 []routing_table.Endpoint
		})
	}
	fake.endpointsForIndexReturnsOnCall[i] = struct {
		result1 []routing_table.Endpoint
	}{result1}
}

func (fake *FakeNATSRoutingTable) MessagesToEmit() routing_table.MessagesToEmit {
	fake.messagesToEmitMutex.Lock()
	ret, specificReturn := fake.messagesToEmitReturnsOnCall[len(fake.messagesToEmitArgsForCall)]
	fake.messagesToEmitArgsForCall = append(fake.messagesToEmitArgsForCall, struct{}{})
	fake.recordInvocation("MessagesToEmit", []interface{}{})
	fake.messagesToEmitMutex.Unlock()
	if fake.MessagesToEmitStub != nil {
		return fake.MessagesToEmitStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.messagesToEmitReturns.result1
}

func (fake *FakeNATSRoutingTable) MessagesToEmitCallCount() int {
	fake.messagesToEmitMutex.RLock()
	defer fake.messagesToEmitMutex.RUnlock()
	return len(fake.messagesToEmitArgsForCall)
}

func (fake *FakeNATSRoutingTable) MessagesToEmitReturns(result1 routing_table.MessagesToEmit) {
	fake.MessagesToEmitStub = nil
	fake.messagesToEmitReturns = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) MessagesToEmitReturnsOnCall(i int, result1 routing_table.MessagesToEmit) {
	fake.MessagesToEmitStub = nil
	if fake.messagesToEmitReturnsOnCall == nil {
		fake.messagesToEmitReturnsOnCall = make(map[int]struct {
			result1 routing_table.MessagesToEmit
		})
	}
	fake.messagesToEmitReturnsOnCall[i] = struct {
		result1 routing_table.MessagesToEmit
	}{result1}
}

func (fake *FakeNATSRoutingTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	fake.setRoutesMutex.RLock()
	defer fake.setRoutesMutex.RUnlock()
	fake.getRoutesMutex.RLock()
	defer fake.getRoutesMutex.RUnlock()
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	fake.endpointsForIndexMutex.RLock()
	defer fake.endpointsForIndexMutex.RUnlock()
	fake.messagesToEmitMutex.RLock()
	defer fake.messagesToEmitMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeNATSRoutingTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routing_table.NATSRoutingTable = new(FakeNATSRoutingTable)
