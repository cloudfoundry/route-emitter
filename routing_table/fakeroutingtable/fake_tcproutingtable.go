// This file was generated by counterfeiter
package fakeroutingtable

import (
	"sync"

	"code.cloudfoundry.org/bbs/models"
	"code.cloudfoundry.org/route-emitter/routing_table"
	"code.cloudfoundry.org/route-emitter/routing_table/schema/event"
)

type FakeTCPRoutingTable struct {
	RouteCountStub        func() int
	routeCountMutex       sync.RWMutex
	routeCountArgsForCall []struct{}
	routeCountReturns     struct {
		result1 int
	}
	routeCountReturnsOnCall map[int]struct {
		result1 int
	}
	AddRoutesStub        func(desiredLRP *models.DesiredLRP) event.RoutingEvents
	addRoutesMutex       sync.RWMutex
	addRoutesArgsForCall []struct {
		desiredLRP *models.DesiredLRP
	}
	addRoutesReturns struct {
		result1 event.RoutingEvents
	}
	addRoutesReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	UpdateRoutesStub        func(beforeLRP, afterLRP *models.DesiredLRP) event.RoutingEvents
	updateRoutesMutex       sync.RWMutex
	updateRoutesArgsForCall []struct {
		beforeLRP *models.DesiredLRP
		afterLRP  *models.DesiredLRP
	}
	updateRoutesReturns struct {
		result1 event.RoutingEvents
	}
	updateRoutesReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	RemoveRoutesStub        func(desiredLRP *models.DesiredLRP) event.RoutingEvents
	removeRoutesMutex       sync.RWMutex
	removeRoutesArgsForCall []struct {
		desiredLRP *models.DesiredLRP
	}
	removeRoutesReturns struct {
		result1 event.RoutingEvents
	}
	removeRoutesReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	AddEndpointStub        func(actualLRP *models.ActualLRPGroup) event.RoutingEvents
	addEndpointMutex       sync.RWMutex
	addEndpointArgsForCall []struct {
		actualLRP *models.ActualLRPGroup
	}
	addEndpointReturns struct {
		result1 event.RoutingEvents
	}
	addEndpointReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	RemoveEndpointStub        func(actualLRP *models.ActualLRPGroup) event.RoutingEvents
	removeEndpointMutex       sync.RWMutex
	removeEndpointArgsForCall []struct {
		actualLRP *models.ActualLRPGroup
	}
	removeEndpointReturns struct {
		result1 event.RoutingEvents
	}
	removeEndpointReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	SwapStub        func(t routing_table.TCPRoutingTable) event.RoutingEvents
	swapMutex       sync.RWMutex
	swapArgsForCall []struct {
		t routing_table.TCPRoutingTable
	}
	swapReturns struct {
		result1 event.RoutingEvents
	}
	swapReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	GetRoutingEventsStub        func() event.RoutingEvents
	getRoutingEventsMutex       sync.RWMutex
	getRoutingEventsArgsForCall []struct{}
	getRoutingEventsReturns     struct {
		result1 event.RoutingEvents
	}
	getRoutingEventsReturnsOnCall map[int]struct {
		result1 event.RoutingEvents
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTCPRoutingTable) RouteCount() int {
	fake.routeCountMutex.Lock()
	ret, specificReturn := fake.routeCountReturnsOnCall[len(fake.routeCountArgsForCall)]
	fake.routeCountArgsForCall = append(fake.routeCountArgsForCall, struct{}{})
	fake.recordInvocation("RouteCount", []interface{}{})
	fake.routeCountMutex.Unlock()
	if fake.RouteCountStub != nil {
		return fake.RouteCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.routeCountReturns.result1
}

func (fake *FakeTCPRoutingTable) RouteCountCallCount() int {
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	return len(fake.routeCountArgsForCall)
}

func (fake *FakeTCPRoutingTable) RouteCountReturns(result1 int) {
	fake.RouteCountStub = nil
	fake.routeCountReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeTCPRoutingTable) RouteCountReturnsOnCall(i int, result1 int) {
	fake.RouteCountStub = nil
	if fake.routeCountReturnsOnCall == nil {
		fake.routeCountReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.routeCountReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeTCPRoutingTable) AddRoutes(desiredLRP *models.DesiredLRP) event.RoutingEvents {
	fake.addRoutesMutex.Lock()
	ret, specificReturn := fake.addRoutesReturnsOnCall[len(fake.addRoutesArgsForCall)]
	fake.addRoutesArgsForCall = append(fake.addRoutesArgsForCall, struct {
		desiredLRP *models.DesiredLRP
	}{desiredLRP})
	fake.recordInvocation("AddRoutes", []interface{}{desiredLRP})
	fake.addRoutesMutex.Unlock()
	if fake.AddRoutesStub != nil {
		return fake.AddRoutesStub(desiredLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addRoutesReturns.result1
}

func (fake *FakeTCPRoutingTable) AddRoutesCallCount() int {
	fake.addRoutesMutex.RLock()
	defer fake.addRoutesMutex.RUnlock()
	return len(fake.addRoutesArgsForCall)
}

func (fake *FakeTCPRoutingTable) AddRoutesArgsForCall(i int) *models.DesiredLRP {
	fake.addRoutesMutex.RLock()
	defer fake.addRoutesMutex.RUnlock()
	return fake.addRoutesArgsForCall[i].desiredLRP
}

func (fake *FakeTCPRoutingTable) AddRoutesReturns(result1 event.RoutingEvents) {
	fake.AddRoutesStub = nil
	fake.addRoutesReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) AddRoutesReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.AddRoutesStub = nil
	if fake.addRoutesReturnsOnCall == nil {
		fake.addRoutesReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.addRoutesReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) UpdateRoutes(beforeLRP *models.DesiredLRP, afterLRP *models.DesiredLRP) event.RoutingEvents {
	fake.updateRoutesMutex.Lock()
	ret, specificReturn := fake.updateRoutesReturnsOnCall[len(fake.updateRoutesArgsForCall)]
	fake.updateRoutesArgsForCall = append(fake.updateRoutesArgsForCall, struct {
		beforeLRP *models.DesiredLRP
		afterLRP  *models.DesiredLRP
	}{beforeLRP, afterLRP})
	fake.recordInvocation("UpdateRoutes", []interface{}{beforeLRP, afterLRP})
	fake.updateRoutesMutex.Unlock()
	if fake.UpdateRoutesStub != nil {
		return fake.UpdateRoutesStub(beforeLRP, afterLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateRoutesReturns.result1
}

func (fake *FakeTCPRoutingTable) UpdateRoutesCallCount() int {
	fake.updateRoutesMutex.RLock()
	defer fake.updateRoutesMutex.RUnlock()
	return len(fake.updateRoutesArgsForCall)
}

func (fake *FakeTCPRoutingTable) UpdateRoutesArgsForCall(i int) (*models.DesiredLRP, *models.DesiredLRP) {
	fake.updateRoutesMutex.RLock()
	defer fake.updateRoutesMutex.RUnlock()
	return fake.updateRoutesArgsForCall[i].beforeLRP, fake.updateRoutesArgsForCall[i].afterLRP
}

func (fake *FakeTCPRoutingTable) UpdateRoutesReturns(result1 event.RoutingEvents) {
	fake.UpdateRoutesStub = nil
	fake.updateRoutesReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) UpdateRoutesReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.UpdateRoutesStub = nil
	if fake.updateRoutesReturnsOnCall == nil {
		fake.updateRoutesReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.updateRoutesReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) RemoveRoutes(desiredLRP *models.DesiredLRP) event.RoutingEvents {
	fake.removeRoutesMutex.Lock()
	ret, specificReturn := fake.removeRoutesReturnsOnCall[len(fake.removeRoutesArgsForCall)]
	fake.removeRoutesArgsForCall = append(fake.removeRoutesArgsForCall, struct {
		desiredLRP *models.DesiredLRP
	}{desiredLRP})
	fake.recordInvocation("RemoveRoutes", []interface{}{desiredLRP})
	fake.removeRoutesMutex.Unlock()
	if fake.RemoveRoutesStub != nil {
		return fake.RemoveRoutesStub(desiredLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeRoutesReturns.result1
}

func (fake *FakeTCPRoutingTable) RemoveRoutesCallCount() int {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return len(fake.removeRoutesArgsForCall)
}

func (fake *FakeTCPRoutingTable) RemoveRoutesArgsForCall(i int) *models.DesiredLRP {
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	return fake.removeRoutesArgsForCall[i].desiredLRP
}

func (fake *FakeTCPRoutingTable) RemoveRoutesReturns(result1 event.RoutingEvents) {
	fake.RemoveRoutesStub = nil
	fake.removeRoutesReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) RemoveRoutesReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.RemoveRoutesStub = nil
	if fake.removeRoutesReturnsOnCall == nil {
		fake.removeRoutesReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.removeRoutesReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) AddEndpoint(actualLRP *models.ActualLRPGroup) event.RoutingEvents {
	fake.addEndpointMutex.Lock()
	ret, specificReturn := fake.addEndpointReturnsOnCall[len(fake.addEndpointArgsForCall)]
	fake.addEndpointArgsForCall = append(fake.addEndpointArgsForCall, struct {
		actualLRP *models.ActualLRPGroup
	}{actualLRP})
	fake.recordInvocation("AddEndpoint", []interface{}{actualLRP})
	fake.addEndpointMutex.Unlock()
	if fake.AddEndpointStub != nil {
		return fake.AddEndpointStub(actualLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.addEndpointReturns.result1
}

func (fake *FakeTCPRoutingTable) AddEndpointCallCount() int {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return len(fake.addEndpointArgsForCall)
}

func (fake *FakeTCPRoutingTable) AddEndpointArgsForCall(i int) *models.ActualLRPGroup {
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	return fake.addEndpointArgsForCall[i].actualLRP
}

func (fake *FakeTCPRoutingTable) AddEndpointReturns(result1 event.RoutingEvents) {
	fake.AddEndpointStub = nil
	fake.addEndpointReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) AddEndpointReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.AddEndpointStub = nil
	if fake.addEndpointReturnsOnCall == nil {
		fake.addEndpointReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.addEndpointReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) RemoveEndpoint(actualLRP *models.ActualLRPGroup) event.RoutingEvents {
	fake.removeEndpointMutex.Lock()
	ret, specificReturn := fake.removeEndpointReturnsOnCall[len(fake.removeEndpointArgsForCall)]
	fake.removeEndpointArgsForCall = append(fake.removeEndpointArgsForCall, struct {
		actualLRP *models.ActualLRPGroup
	}{actualLRP})
	fake.recordInvocation("RemoveEndpoint", []interface{}{actualLRP})
	fake.removeEndpointMutex.Unlock()
	if fake.RemoveEndpointStub != nil {
		return fake.RemoveEndpointStub(actualLRP)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeEndpointReturns.result1
}

func (fake *FakeTCPRoutingTable) RemoveEndpointCallCount() int {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return len(fake.removeEndpointArgsForCall)
}

func (fake *FakeTCPRoutingTable) RemoveEndpointArgsForCall(i int) *models.ActualLRPGroup {
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	return fake.removeEndpointArgsForCall[i].actualLRP
}

func (fake *FakeTCPRoutingTable) RemoveEndpointReturns(result1 event.RoutingEvents) {
	fake.RemoveEndpointStub = nil
	fake.removeEndpointReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) RemoveEndpointReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.RemoveEndpointStub = nil
	if fake.removeEndpointReturnsOnCall == nil {
		fake.removeEndpointReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.removeEndpointReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) Swap(t routing_table.TCPRoutingTable) event.RoutingEvents {
	fake.swapMutex.Lock()
	ret, specificReturn := fake.swapReturnsOnCall[len(fake.swapArgsForCall)]
	fake.swapArgsForCall = append(fake.swapArgsForCall, struct {
		t routing_table.TCPRoutingTable
	}{t})
	fake.recordInvocation("Swap", []interface{}{t})
	fake.swapMutex.Unlock()
	if fake.SwapStub != nil {
		return fake.SwapStub(t)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.swapReturns.result1
}

func (fake *FakeTCPRoutingTable) SwapCallCount() int {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return len(fake.swapArgsForCall)
}

func (fake *FakeTCPRoutingTable) SwapArgsForCall(i int) routing_table.TCPRoutingTable {
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	return fake.swapArgsForCall[i].t
}

func (fake *FakeTCPRoutingTable) SwapReturns(result1 event.RoutingEvents) {
	fake.SwapStub = nil
	fake.swapReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) SwapReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.SwapStub = nil
	if fake.swapReturnsOnCall == nil {
		fake.swapReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.swapReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) GetRoutingEvents() event.RoutingEvents {
	fake.getRoutingEventsMutex.Lock()
	ret, specificReturn := fake.getRoutingEventsReturnsOnCall[len(fake.getRoutingEventsArgsForCall)]
	fake.getRoutingEventsArgsForCall = append(fake.getRoutingEventsArgsForCall, struct{}{})
	fake.recordInvocation("GetRoutingEvents", []interface{}{})
	fake.getRoutingEventsMutex.Unlock()
	if fake.GetRoutingEventsStub != nil {
		return fake.GetRoutingEventsStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.getRoutingEventsReturns.result1
}

func (fake *FakeTCPRoutingTable) GetRoutingEventsCallCount() int {
	fake.getRoutingEventsMutex.RLock()
	defer fake.getRoutingEventsMutex.RUnlock()
	return len(fake.getRoutingEventsArgsForCall)
}

func (fake *FakeTCPRoutingTable) GetRoutingEventsReturns(result1 event.RoutingEvents) {
	fake.GetRoutingEventsStub = nil
	fake.getRoutingEventsReturns = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) GetRoutingEventsReturnsOnCall(i int, result1 event.RoutingEvents) {
	fake.GetRoutingEventsStub = nil
	if fake.getRoutingEventsReturnsOnCall == nil {
		fake.getRoutingEventsReturnsOnCall = make(map[int]struct {
			result1 event.RoutingEvents
		})
	}
	fake.getRoutingEventsReturnsOnCall[i] = struct {
		result1 event.RoutingEvents
	}{result1}
}

func (fake *FakeTCPRoutingTable) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.routeCountMutex.RLock()
	defer fake.routeCountMutex.RUnlock()
	fake.addRoutesMutex.RLock()
	defer fake.addRoutesMutex.RUnlock()
	fake.updateRoutesMutex.RLock()
	defer fake.updateRoutesMutex.RUnlock()
	fake.removeRoutesMutex.RLock()
	defer fake.removeRoutesMutex.RUnlock()
	fake.addEndpointMutex.RLock()
	defer fake.addEndpointMutex.RUnlock()
	fake.removeEndpointMutex.RLock()
	defer fake.removeEndpointMutex.RUnlock()
	fake.swapMutex.RLock()
	defer fake.swapMutex.RUnlock()
	fake.getRoutingEventsMutex.RLock()
	defer fake.getRoutingEventsMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeTCPRoutingTable) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ routing_table.TCPRoutingTable = new(FakeTCPRoutingTable)
